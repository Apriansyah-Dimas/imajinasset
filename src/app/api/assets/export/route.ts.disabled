import { NextRequest, NextResponse } from 'next/server'
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

export async function GET(
  request: NextRequest
) {
  try {
    // Get all assets with their relations and custom values
    const assets = await prisma.asset.findMany({
      orderBy: {
        dateCreated: 'desc'
      },
      include: {
        site: true,
        category: true,
        department: true,
        customValues: {
          include: {
            customField: true
          }
        }
      }
    })

    // Get all active custom fields for headers
    const customFields = await prisma.assetCustomField.findMany({
      where: { isactive: true },
      orderBy: { createdat: 'asc' }
    })

    // Build CSV headers
    const baseHeaders = [
      'NameOfAsset',
      'NoAsset',
      'Status',
      'SerialNo',
      'PurchaseDate',
      'Cost',
      'Brand',
      'Model',
      'Site',
      'Category',
      'Department',
      'PIC',
      'DateCreated'
    ]

    const customFieldHeaders = customFields.map(field => field.label)
    const headers = [...baseHeaders, ...customFieldHeaders]

    const csvRows = [
      headers.join(','),
      ...assets.map(asset => {
        // Base asset data
        const baseRow = [
          // Escape commas and quotes in asset name
          `"${asset.name.replace(/"/g, '""')}"`,
          asset.noAsset,
          asset.status || '',
          asset.serialNo || '',
          asset.purchaseDate ? asset.purchaseDate.toISOString().split('T')[0] : '',
          asset.cost?.toString() || '',
          asset.brand || '',
          asset.model || '',
          asset.site?.name || '',
          asset.category?.name || '',
          asset.department?.name || '',
          asset.pic || '',
          asset.dateCreated.toISOString().split('T')[0]
        ]

        // Custom field values
        const customFieldValues = customFields.map(field => {
          const customValue = asset.customValues.find(cv => cv.customFieldId === field.id)

          if (!customValue) return ''

          switch (field.fieldType) {
            case 'TEXT':
            case 'TEXTAREA':
            case 'SELECT':
              return `"${(customValue.stringValue || '').replace(/"/g, '""')}"`
            case 'NUMBER':
              return customValue.numberValue?.toString() || ''
            case 'DATE':
              return customValue.dateValue ? new Date(customValue.dateValue).toISOString().split('T')[0] : ''
            case 'BOOLEAN':
              return customValue.booleanValue ? 'Yes' : 'No'
            default:
              return ''
          }
        })

        const row = [...baseRow, ...customFieldValues]
        return row.join(',')
      })
    ]

    const csvContent = csvRows.join('\n')

    // Create response with CSV content
    const response = new NextResponse(csvContent, {
      headers: {
        'Content-Type': 'text/csv; charset=utf-8',
        'Content-Disposition': `attachment; filename="assets-export-${new Date().toISOString().split('T')[0]}.csv"`
      }
    })

    return response
  } catch (error) {
    console.error('Export assets error:', error)
    return NextResponse.json(
      { error: 'Failed to export assets' },
      { status: 500 }
    )
  }
}